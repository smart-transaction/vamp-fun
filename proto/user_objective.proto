syntax = "proto3";

package vamp.fun;

message CallObjectProto {
  uint64 id = 1;
  uint64 chain_id = 2;
  bytes salt = 3;
  bytes amount = 4;
  bytes gas = 5;
  bytes address = 6;
  bool skippable = 7;
  bool verifiable = 8;
  bytes callvalue = 9;
  bytes returnvalue = 10;
}

message UserObjectiveProto {
  bytes app_id = 1;
  uint64 nonse = 2;
  uint64 chain_id = 3;
  repeated CallObjectProto call_objects = 4;
}

message AdditionalDataProto {
  bytes key = 1;
  bytes value = 2;
}

message UserEventProto {
  bytes app_id = 1;
  uint64 chain_id = 2;
  uint64 block_number = 3;
  UserObjectiveProto user_objective = 4;
  repeated AdditionalDataProto additional_data = 5;
}

enum AppChainResultStatus {
  OK = 0;
  EVENT_NOT_FOUND = 20;
  ERROR = 30;
}

message AppChainResultProto {
  AppChainResultStatus status = 1;
  optional string message = 2;
}

message PollRequestProto {
  uint64 last_sequence_id = 1;
}

message PollResponseProto {
  uint64 sequence_id = 1;
  AppChainResultProto result = 2;
  optional bytes request_id = 3;
  UserEventProto event = 4;
}

message SolverDecisionRequestProto {
  bytes app_id = 1;
  uint64 sequence_id = 2;
  UserEventProto event = 3;
}

message SolverDecisionResponseProto {
  AppChainResultProto result = 1;
}

service RequestRegistratorService {
  // To be called periodically from the solver to the request registrator
  // to check if there are new requests to be solved.
  rpc Poll(PollRequestProto) returns (PollResponseProto);
}

service OrchestratorService{
  // To be called from the solver to the orchestrator to deliver the solver decision.
  rpc SolverDecision(SolverDecisionRequestProto) returns (SolverDecisionResponseProto);
}
